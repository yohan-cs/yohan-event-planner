package com.yohan.event_planner.domain;

import com.yohan.event_planner.domain.enums.Role;
import jakarta.persistence.*;
import jakarta.validation.constraints.Email;

import java.util.HashSet;
import java.util.Set;

/**
 * Entity representing a registered user of the application.
 *
 * <p>This entity supports core account functionality including registration, authentication,
 * soft deletion, role-based authorization, profile visibility, and timezone tracking.</p>
 *
 * <p>All persistence is managed via JPA. User records are stored in the {@code users} table,
 * and associated roles are stored in the {@code user_roles} table via an element collection.</p>
 */
@Entity
@Table(name = "users")
public class User {

    /** Unique identifier for the user. Auto-generated by the database. */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /** Unique, case-insensitive username used for login and identification. */
    @Column(nullable = false, unique = true, length = 50)
    private String username;

    /** The hashed password. */
    @Column(nullable = false)
    private String hashedPassword;

    /** Unique, valid email address used for communication and login. */
    @Email
    @Column(nullable = false, unique = true)
    private String email;

    /** User’s first name. */
    @Column(nullable = false, length = 50)
    private String firstName;

    /** User’s last name. */
    @Column(nullable = false, length = 50)
    private String lastName;

    /** Timezone ID associated with the user, used for event scheduling and notifications. */
    @Column(nullable = false)
    private String timezone;

    /**
     * Role-based access control.
     * <p>Each user is assigned one or more roles (e.g., USER, MOD, ADMIN).
     * Default is {@link Role#USER}.</p>
     */
    @ElementCollection(fetch = FetchType.EAGER)
    @CollectionTable(name = "user_roles", joinColumns = @JoinColumn(name = "user_id"))
    @Enumerated(EnumType.STRING)
    @Column(name = "role", nullable = false)
    private Set<Role> roles = new HashSet<>(Set.of(Role.USER));

    /** Indicates whether the account is active. Inactive users are considered banned. */
    @Column(nullable = false)
    private boolean active = true;

    /** Indicates whether the account has been soft-deleted. Deleted users are excluded from active interactions. */
    @Column(nullable = false)
    private boolean deleted = false;


    /** Default constructor required by JPA. */
    protected User() {
        // for JPA
    }

    /**
     * Constructs a new user instance with mandatory fields.
     *
     * @param username  unique username
     * @param hashedPassword  hashed password
     * @param email     unique email address
     * @param firstName user's first name
     * @param lastName  user's last name
     * @param timezone  user's timezone ID
     */
    public User(String username, String hashedPassword, String email, String firstName, String lastName, String timezone) {
        this.username = username;
        this.hashedPassword = hashedPassword;
        this.email = email;
        this.firstName = firstName;
        this.lastName = lastName;
        this.timezone = timezone;
        addRole(Role.USER);  // Default role is USER
    }

    // --- Getters ---

    /**
     * Returns the unique identifier for the user.
     *
     * @return the user ID
     */
    public Long getId() {
        return id;
    }

    /**
     * Returns the unique username for the user.
     *
     * @return the username of the user
     */
    public String getUsername() {
        return username;
    }

    /**
     * Returns the user's hashed password.
     *
     * @return the hashed password of the user
     */
    public String getHashedPassword() {
        return hashedPassword;
    }

    /**
     * Returns the user's email address.
     *
     * @return the email address of the user
     */
    public String getEmail() {
        return email;
    }

    /**
     * Returns the user's first name.
     *
     * @return the first name of the user
     */
    public String getFirstName() {
        return firstName;
    }

    /**
     * Returns the user's last name.
     *
     * @return the last name of the user
     */
    public String getLastName() {
        return lastName;
    }

    /**
     * Returns the user's timezone ID.
     *
     * @return the timezone ID of the user
     */
    public String getTimezone() {
        return timezone;
    }

    /**
     * Returns the roles assigned to the user.
     *
     * @return a set of roles assigned to the user
     */
    public Set<Role> getRoles() {
        return Set.copyOf(roles);
    }

    /**
     * Returns whether the user's account is active.
     *
     * @return true if the user account is active, false if banned
     */
    public boolean isActive() {
        return active;
    }

    /**
     * Returns whether the user's account has been soft-deleted.
     *
     * @return true if the account has been deleted, false otherwise
     */
    public boolean isDeleted() {
        return deleted;
    }

    // --- Setters ---

    public void setUsername(String username) {
        this.username = username;
    }

    public void setHashedPassword(String hashedPassword) {
        this.hashedPassword = hashedPassword;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    public void setTimezone(String timezone) {
        this.timezone = timezone;
    }
    public void addRole(Role role) {
        this.roles.add(role);
    }

    public void removeRole(Role role) {
        this.roles.remove(role);
    }

    public void setActive(boolean active) {
        this.active = active;
    }

    public void setDeleted(boolean deleted) {
        this.deleted = deleted;
    }

    // --- Equality & Hashing ---

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof User other)) return false;

        if (id != null && other.getId() != null) {
            return id.equals(other.getId());
        }

        return username != null && email != null &&
                username.equals(other.getUsername()) &&
                email.equals(other.getEmail());
    }

    @Override
    public int hashCode() {
        if (id != null) return id.hashCode();
        return (username != null ? username.hashCode() : 0) ^ (email != null ? email.hashCode() : 0);
    }
}
