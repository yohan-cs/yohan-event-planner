package com.yohan.event_planner.domain;

import com.yohan.event_planner.domain.enums.Role;
import jakarta.persistence.*;
import jakarta.validation.constraints.Email;

import java.util.HashSet;
import java.util.Set;

/**
 * Entity representing a registered user of the application.
 *
 * <p>This entity supports core account functionality including registration, authentication,
 * soft deletion, role-based authorization, profile visibility, and timezone tracking.</p>
 *
 * <p>All persistence is managed via JPA. User records are stored in the {@code users} table,
 * and associated roles are stored in the {@code user_roles} table via an element collection.</p>
 */
@Entity
@Table(name = "users")
public class User {

    /** Unique identifier for the user. Auto-generated by the database. */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /** Unique, case-insensitive username used for login and identification. */
    @Column(nullable = false, unique = true, length = 50)
    private String username;

    /** The hashed password. */
    @Column(name = "hashedpassword", nullable = false)  // Updated to match database column
    private String hashedPassword;

    /** Unique, valid email address used for communication and login. */
    @Email
    @Column(nullable = false, unique = true)
    private String email;

    /** User’s first name. */
    @Column(name = "firstname", nullable = false, length = 50)  // Updated to match database column
    private String firstName;

    /** User’s last name. */
    @Column(name = "lastname", nullable = false, length = 50)  // Updated to match database column
    private String lastName;

    /** Timezone ID associated with the user, used for event scheduling and notifications. */
    @Column(nullable = false)
    private String timezone;

    /**
     * Role-based access control.
     * <p>Each user is assigned one or more roles (e.g., USER, MOD, ADMIN).
     * Default is {@link Role#USER}.</p>
     */
    @ElementCollection(fetch = FetchType.EAGER)
    @CollectionTable(name = "user_roles", joinColumns = @JoinColumn(name = "user_id"))
    @Enumerated(EnumType.STRING)
    @Column(name = "role", nullable = false)
    private Set<Role> roles = new HashSet<>(Set.of(Role.USER));

    /** Indicates whether the account is active. Inactive users are considered banned. */
    @Column(nullable = false)
    private boolean active = true;

    /** Indicates whether the account has been soft-deleted. Deleted users are excluded from active interactions. */
    @Column(nullable = false)
    private boolean deleted = false;

    /** Default constructor required by JPA. */
    protected User() {
        // for JPA
    }

    /**
     * Constructs a new user instance with mandatory fields.
     *
     * @param username  unique username
     * @param hashedPassword  hashed password
     * @param email     unique email address
     * @param firstName user's first name
     * @param lastName  user's last name
     * @param timezone  user's timezone ID
     */
    public User(String username, String hashedPassword, String email, String firstName, String lastName, String timezone) {
        this.username = username;
        this.hashedPassword = hashedPassword;
        this.email = email;
        this.firstName = firstName;
        this.lastName = lastName;
        this.timezone = timezone;
        addRole(Role.USER);  // Default role is USER
    }

    // --- Getters ---
    public Long getId() { return id; }
    public String getUsername() { return username; }
    public String getHashedPassword() { return hashedPassword; }
    public String getEmail() { return email; }
    public String getFirstName() { return firstName; }
    public String getLastName() { return lastName; }
    public String getTimezone() { return timezone; }
    public Set<Role> getRoles() { return Set.copyOf(roles); }
    public boolean isActive() { return active; }
    public boolean isDeleted() { return deleted; }

    // --- Setters ---
    public void setUsername(String username) { this.username = username; }
    public void setHashedPassword(String hashedPassword) { this.hashedPassword = hashedPassword; }
    public void setEmail(String email) { this.email = email; }
    public void setFirstName(String firstName) { this.firstName = firstName; }
    public void setLastName(String lastName) { this.lastName = lastName; }
    public void setTimezone(String timezone) { this.timezone = timezone; }
    public void addRole(Role role) { this.roles.add(role); }
    public void removeRole(Role role) { this.roles.remove(role); }
    public void setActive(boolean active) { this.active = active; }
    public void setDeleted(boolean deleted) { this.deleted = deleted; }

    // --- Equality & Hashing ---
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof User other)) return false;

        if (id != null && other.getId() != null) {
            return id.equals(other.getId());
        }

        return username != null && email != null &&
                username.equals(other.getUsername()) &&
                email.equals(other.getEmail());
    }

    @Override
    public int hashCode() {
        if (id != null) return id.hashCode();
        return (username != null ? username.hashCode() : 0) ^ (email != null ? email.hashCode() : 0);
    }
}
